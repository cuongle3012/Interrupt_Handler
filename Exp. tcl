############################################################
# Input file (space-separated text file)
############################################################
set infile "data.txt"

############################################################
# STEP 1: Read clock relationships
# - Which clock is generated
# - Which clock is its master
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header line

array set master_of {}
array set is_generated {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk    [lindex $f 0]
    set isgen  [lindex $f 2]
    set master [lindex $f 3]

    # Save clock relationships
    set is_generated($clk) $isgen
    set master_of($clk)    $master
}
close $fp

############################################################
# FUNCTION: Find the root master clock
# - Follow the master clock step by step
# - Stop when the clock is not generated anymore
############################################################
proc get_root_clock {clk} {
    global master_of is_generated

    set cur $clk
    set visited {}

    while {1} {
        # Stop if a loop is detected
        if {[lsearch -exact $visited $cur] >= 0} {
            return $cur
        }
        lappend visited $cur

        # If this clock is not generated, it is the root
        if {![info exists is_generated($cur)] || $is_generated($cur) ne "TRUE"} {
            return $cur
        }

        # If no master clock exists, stop here
        if {![info exists master_of($cur)]} {
            return $cur
        }

        set next $master_of($cur)

        # If the clock points to itself, stop
        if {$next eq $cur} {
            return $cur
        }

        # Move to the next master clock
        set cur $next
    }
}

############################################################
# STEP 2: Group data by ROOT CLOCK
# - Sum sinks
# - Calculate weighted latency
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header line

array set sum_sink {}
array set sum_weight {}
array set last_info {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk     [lindex $f 0]
    set period  [lindex $f 1]
    set isgen   [lindex $f 2]
    set port    [lindex $f 4]
    set sinks   [lindex $f 5]
    set latency [lindex $f 6]

    if {$isgen eq "TRUE"} {
        # Find the real (root) master clock
        set root [get_root_clock $clk]

        # Add sinks to this root clock
        incr sum_sink($root) $sinks

        # Add weighted latency (latency Ã— sinks)
        set sum_weight($root) \
            [expr {[info exists sum_weight($root)] \
            ? $sum_weight($root) + $latency * $sinks \
            : $latency * $sinks}]

        # Save info from the last line (for output)
        set last_info($root) [list $period $port]
    }
}
close $fp

############################################################
# STEP 3: Print result
# - One output per root clock
############################################################
foreach root [lsort [array names sum_sink]] {
    lassign $last_info($root) period port

    # Final latency = weighted average
    set final_latency [expr {$sum_weight($root) / double($sum_sink($root))}]
    set final_latency [format "%.4f" $final_latency]

    puts "# clock=$root period=$period sinks=$sum_sink($root)"
    puts "set latency -source $root -($final_latency) \[get_port $port\] -clock $root\n"
}
