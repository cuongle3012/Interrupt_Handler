############################################################
# Input file (space-separated text)
############################################################
set infile "data.txt"

############################################################
# STEP 1: Read clock relationships
# Build:
#   - master_of(clock) -> master clock
#   - is_generated(clock) -> TRUE / FALSE
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header

array set master_of {}
array set is_generated {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk    [lindex $f 0]
    set isgen  [lindex $f 2]
    set master [lindex $f 3]

    set master_of($clk)    $master
    set is_generated($clk) $isgen
}
close $fp

############################################################
# FUNCTION: Find the root master clock
# - Follow master clock chain upward
# - Stop when clock is no longer generated
############################################################
proc get_root_clock {clk master_of_name is_generated_name} {
    upvar $master_of_name master_of
    upvar $is_generated_name is_generated

    set cur $clk
    set visited {}

    while {1} {
        # Prevent infinite loop
        if {[lsearch -exact $visited $cur] >= 0} {
            return $cur
        }
        lappend visited $cur

        # If clock is not generated, this is the root
        if {![info exists is_generated($cur)] || $is_generated($cur) ne "TRUE"} {
            return $cur
        }

        # If no master is defined, stop here
        if {![info exists master_of($cur)]} {
            return $cur
        }

        set next $master_of($cur)

        # Self reference means root
        if {$next eq $cur} {
            return $cur
        }

        # Move up to the master clock
        set cur $next
    }
}

############################################################
# STEP 2: Group data by ROOT CLOCK
# - Sum sinks
# - Sum weighted latency (latency Ã— sinks)
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header

array set sum_sink {}
array set sum_weight {}
array set last_info {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk     [lindex $f 0]
    set period  [lindex $f 1]
    set isgen   [lindex $f 2]
    set port    [lindex $f 4]
    set sinks   [lindex $f 5]
    set latency [lindex $f 6]

    if {$isgen eq "TRUE"} {
        # Find real root master clock
        set root [get_root_clock $clk master_of is_generated]

        # Add sinks
        incr sum_sink($root) $sinks

        # Add weighted latency
        set sum_weight($root) \
            [expr {[info exists sum_weight($root)] \
            ? $sum_weight($root) + $latency * $sinks \
            : $latency * $sinks}]

        # Save info from last line for output
        set last_info($root) [list $period $port]
    }
}
close $fp

############################################################
# STEP 3: Print final result
# One output per ROOT CLOCK
############################################################
foreach root [lsort [array names sum_sink]] {
    lassign $last_info($root) period port

    # Final latency = weighted average
    set final_latency [expr {$sum_weight($root) / double($sum_sink($root))}]
    set final_latency [format "%.3f" $final_latency]

    puts "# clock=$root period=$period sinks=$sum_sink($root)"
    puts "set latency -source $root -($final_latency) \[get_port $port\] -clock $root\n"
}
