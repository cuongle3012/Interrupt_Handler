############################################################
# Input file (space-separated text)
############################################################
set infile "data.txt"

############################################################
# STEP 1: Read clock information
# Build:
#   - clock_exist(clock)  : clock name exists in file
#   - master_of(clock)   : direct master clock
#   - is_generated(clock): TRUE / FALSE
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header

array set clock_exist {}
array set master_of {}
array set is_generated {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk    [lindex $f 0]
    set isgen  [lindex $f 2]
    set master [lindex $f 3]

    set clock_exist($clk) 1
    set is_generated($clk) $isgen

    if {$master ne "" && $master ne "-"} {
        set master_of($clk) $master
    }
}
close $fp

############################################################
# FUNCTION: Find ROOT clock
# Rules:
# 1. Only called for is_generated == TRUE clocks
# 2. Always check master clock first
# 3. If master exists in clock list:
#    - If master is generated -> continue tracing
#    - If master is NOT generated -> master is root
# 4. If master does not exist -> master is root
############################################################
proc get_root_clock {clk master_of_name is_generated_name clock_exist_name} {
    upvar $master_of_name master_of
    upvar $is_generated_name is_generated
    upvar $clock_exist_name clock_exist

    set cur $clk
    set visited {}

    while {1} {
        # Protect against infinite loop
        if {[lsearch -exact $visited $cur] >= 0} {
            return $cur
        }
        lappend visited $cur

        # If no master clock, current clock is root
        if {![info exists master_of($cur)]} {
            return $cur
        }

        set master $master_of($cur)

        # If master clock does not exist in clock list, use it as root
        if {![info exists clock_exist($master)]} {
            return $master
        }

        # If master exists but is NOT generated, it is root
        if {![info exists is_generated($master)] || $is_generated($master) ne "TRUE"} {
            return $master
        }

        # Master is generated -> continue tracing upward
        set cur $master
    }
}

############################################################
# STEP 2: Group and calculate (ONLY generated clocks)
# - Group by ROOT clock
# - Sum sinks
# - Sum weighted latency (latency Ã— sinks)
############################################################
set fp [open $infile r]
gets $fp   ;# Skip header

array set sum_sink {}
array set sum_weight {}
array set last_info {}

while {[gets $fp line] >= 0} {
    set f [split $line]

    set clk     [lindex $f 0]
    set period  [lindex $f 1]
    set isgen   [lindex $f 2]
    set port    [lindex $f 4]
    set sinks   [lindex $f 5]
    set latency [lindex $f 6]

    # Only handle generated clocks
    if {$isgen ne "TRUE"} {
        continue
    }

    # Find root clock
    set root [get_root_clock $clk master_of is_generated clock_exist]

    # Accumulate sinks
    incr sum_sink($root) $sinks

    # Accumulate weighted latency
    set sum_weight($root) \
        [expr {[info exists sum_weight($root)] \
        ? $sum_weight($root) + $latency * $sinks \
        : $latency * $sinks}]

    # Save last line info for output
    set last_info($root) [list $period $port]
}
close $fp

############################################################
# STEP 3: Output result
# - One output per ROOT clock
# - Latency is weighted average
############################################################
foreach root [lsort [array names sum_sink]] {
    lassign $last_info($root) period port

    set final_latency [expr {$sum_weight($root) / double($sum_sink($root))}]
    set final_latency [format "%.3f" $final_latency]

    puts "# clock=$root period=$period sinks=$sum_sink($root)"
    puts "set latency -source $root -($final_latency) \[get_port $port\] -clock $root\n"
}
